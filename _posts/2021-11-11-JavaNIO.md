---
title:  "Java NIO"
excerpt: Java NIO
categories:
  - Java
---


## 자바 IO 프로세스
1. 프로세스가 커널에 파일 읽기 명령을 내림
2. 커널은 시스템콜(read())을 사용해 디스크 컨트롤러가 물리적 디스크로부터 읽어온 파일 데이터를 커널 영역안의 버퍼에 쓴다.
3. 모든 파일 데이터가 버퍼에 복사되면 다시 프로세스 안의 버퍼로 복사
4. 프로세스 안의 버퍼 내용으로 프로그래밍

#### 자바 기존 IO 단점

커널 버퍼의 데이터를 프로세스 안으로 다시 복사하기 때문에 I/O 프로세스 세번째 과정은 비효율적이다. 커널영역에 바로 접근할 수 있다면 버퍼를 복사하는 CPU를 낭비하지 않고 GC관리를 따로 하지 않아도 IO를 사용할 수 있게 된다.
  
IO 프로세스를 거치는 동안 작업을 요청한 쓰레드는 블로킹 되어 속도가 늦춰진다.

#### 커널 Buffer
커널 버퍼란 운영체제가 관리하는 메모리 영역에 생성되는 버퍼공간으로 자바는 외부데이터를 가져올 때 OS의 메모리 버퍼에 먼저 담은 후 JVM 내의 버퍼에 한번 더 옮겨줘야 하기 때문에 시스템 메모리를 지겁 다루는 C언어에 비해 입출력이 느리다.
  
이러한 단점을 개선하기 위해 나온 ByteBuffer 클래스의 allocateDirect() 메서드를 사용하면 커널 버퍼를 사용할 수 있다. 그 외에 만들어지는 버퍼는 모두 JVM 내에 생성되는 버퍼

## NIO(New Input/Output)
- 기존 IO의 단점을 개선하기 위해 JDK 4부터 추가된 패키지
- 현재는 JDK 7에서 한번 더 버전업하여 NIO.2 API와 함께 제공되고 있는 패키지. (NIO.2 API는 java.io와 java.nio 사이의 일관성 없는 클래스 설계를 바로 잡고, 비동기 채널등의 네트워크 지원을 대폭 강화

NIO 패키지 | 설명
---- | ----
java.nio | 다양한 버퍼 클래스
java.nio.channels | 파일 채널, TCP 채널, UDP 채널 등의 클래스
java.nio.channels.spi | java.nio.channels 패키지를 위한 서비스 제공자 클래스
java.nio.charset | 문자셋, 인코더, 디코더 API
java.nio.charset.spi | java.nio.charset 패키지를 위한 서비스 제공자 클래스
java.nio.file | 파일 및 파일 시스템에 접근하기 위한 클래스
java.nio.file.attribute | 파일 및 파일 시스템의 속성에 접근하기 위한 클래스
java.nio.file.spi | java.nio.file 패키지를 위한 서비스 제공자 클래스

#### IO와 NIO 차이

구분 | IO | NIO
---- | ---- | ----
입출력방식 | 스트림방식 | 채널방식
버퍼방식 | 논버퍼 | 버퍼
비동기방식 | 지원안함 | 지원
블로킹/논블로킹방식 | 블로킹방식 지원 | 블로킹/논블로킹 지원

#### 스트림과 채널
- IO는 스트림기반으로 입력과 출력 스트림이 구분되어 있어 데이터를 읽기 위해서는 입력스트림을 생성하고, 출력하기 위해서는 출력스트림을 생성해야한다.
- NIO는 채널기반으로 스트림과 달리 양방향 입출력이 가능하다. 따라서 입력과 출력을 위한 별도의 채널을 만들 필요가 없다.

#### 논버퍼와 버퍼
- IO는 스트림에서 읽은 데이터를 즉시 처리한다. 출력스트림이 1바이트를 쓰면 입력스트림이 1바이트를 읽는다. 그래서 성능을 보완하게 위해 보조스트림 BufferedInputStream, BufferedOutputStream을 연결해 사용한다.
- NIO는 읽은 데이터를 버퍼에 저장한다. 기본적으로 버퍼를 사용해서 입출력을 하기 때문에 IO보다 높은 성능을 가진다.

#### 블로킹 논블로킹
- IO는 입력스트림의 read()나 출력스트림의 write()를 호출하면 데이터가 입출력되기 전까지 쓰레드는 블로킹된다. IO 쓰레드가 블로킹되면 다른 일을 할 수 없고 블로킹을 빠져나오기 위해 인터럽트도 할 수 없다.
- NIO는 블로킹/논블로킹 특징을 모두 가지고 있다. 하지만 일반 IO와 다르게 NIO의 블로킹은 스레드를 인터럽트함으로써 블로킹에서 빠져나올 수 있다. 또한 NIO는 입출력 작업이 준비된 채널에 한해서 작업 스레드가 처리하기 때문에 논블로킹 특징도 가지게 된다.


## NIO 핵심요소

명칭 | 설명
---- | ----
Buffer | 입출력 데이터를 임시로 저장할 때 사용
Charset | 바이트 데이터와 문자 데이터를 인코딩/디코딩할 때 사용
Channel | 데이터가 통과하는 스트림을 의미
Selector | 하나의 쓰레드에서 다중 채널로부터 들어오는 입력 데이터를 처리할 수 있도록 해주는 멀티플렉서<br> NIO 논블로킹 입출력의 핵심요소

## 버퍼(Buffer)
- NIO의 버퍼 역시 보조스트림에서 사용했던 BufferedInputStream, BufferedOutputStream과 기능이 동일. 마찬가지로 바이트를 버퍼에 저장했다가 한번에 출력해주는 역할을 하게 된다.
- NIO의 버퍼는 데이터 타입에 따라 그리고 버퍼가 사용하는 메모리의 위치에 따라 종류가 나뉘게 된다.

#### 데이터 타입에 따른 버퍼

종류 | Direct/NonDirect<br>버퍼여부 | 채널 사용여부
---- | ---- | ----
ByteBuffer | 둘다 가능 | ReadableByteChannel과 WritableButeChannel을 통해 데이터 입출력
MappedByteBuffer | byte | 가능(특정영역에 메모리 매핑)
CharBuffer | 둘다 가능 | 사용 불가능
DoubleBuffer | 둘다 가능 | 사용 불가능
FloatBuffer | 둘다 가능 | 가능
IntBuffer | 둘다 가능 | 가능
LongBuffer | 둘다 가능 | 가능
ShortBuffer | 둘다 가능 | 가능

  
#### Direct/NonDirect Buffer

구분 | DirectBuffer | NonDirectBuffer
---- | ---- | ----
사용공간 | OS 메모리 | JVM 힙메모리
버퍼의 생성속도 | 느림 | 빠름
버퍼의 크기 | 큼 | 작음
I/O 성능 | 높음 | 낮음
USE | 한번 생성한 뒤 재사용할 경우 | 빈번하게 계속해서 사용해야 할 경우

#### Buffer 속성 및 메서드

 - 속성
  
```java
  private int mark = -1;
  private int position = 0;
  private int limit;
  private int capacity;
```  


속성 | 설명
---- | ----
용량(capacity) | 버퍼의 용량으로 버퍼의 총 크기
위치(position) | 버퍼에서 다음에 읽거나 쓰는 부분
제한(limit) | 실제 사용할 수 있는 버퍼의 크기
마크(mark) | reset() 사용시 돌아갈 위치


- Buffer클래스 메서드

  
메서드 | 설명
---- | ----
clear() | 모든 속성값 초기화
rewind() | position와 makr 값 초기화
flip() | limt을 position 으로 설정 후 position은 0 으로 이동. mark 초기화
reset() | position을 mark 위치로 이동
mark() | 현재 위치를 mark에 저장
capacity() | 버퍼의 전체 크기 리턴(capacity 리턴)

- 기타 주요 메서드 (ByteBuffer클래스)

메서드 | 설명
---- | ----
allocate(int capacity) | capacity 크기의 논다이렉트 버퍼를 생성
allocateDirect(int capacity) | ByteBuffer 클래스에만 있는 메서드로 다이렉트 버퍼를 생성
asXXXBuffer() | 다이렉트 버퍼 생성은 ByteBuffer 클래스만 가능하지만 해당 함수를 사용하면 ByteBuffer를 다른 유형의 버퍼로 변환이 가능
wrap(byte[] array) | 바이트 배열을 사용하여 버퍼를 생성
getXXX() /putXXX() | 클래스의 getter/setter와 같은 쓰임새. get/put에는 상대적인 것과 절대적인 것이 존재하는데, 매개변수가 있을 경우 절대적(해당 posotion에 직접 세팅)

## 채널
