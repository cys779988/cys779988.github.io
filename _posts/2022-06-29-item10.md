---
title:  "equals는 일반 규약을 지켜 재정의하라"
excerpt: equals는 일반 규약을 지켜 재정의하라
categories:
  - effectiveJava
---

## equals 재정의 시 고려사항

1. 각 인스턴스가 본질적으로 고유한 경우  
값을 표현하는 게 아니라 동작하는 개체를 표현하는 클래스가 여기 해당한다. ex) Thread.class

2. 인스턴스의 논리적 동치성을 검사할 필요 없는 경우  
예컨대 java.util.regex.Pattern은 equals를 재정의해서 두 Pattern의 인스턴스가 같은 정규표현식을 나타내는지를 검사하는 방법도 있다. 하지만 설계자는 클라이언트가 이 방식을 원하지 않거나 필요없다고 판단한다면 Object의 기본 equals만으로 해결된다.

3. 상위 클래스에서 재정의한 equals를 하위 클래스에서 사용해도 되는 경우  
대부분의 Set, List, Map 구현체들은 추상 클래스로부터 상속받아 equals를 그대로 쓴다.

4. 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없는 경우

## equals 재정의해야 할 경우
객체 식별성(두 객체가 물리적으로 같은가)이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때. 주로 값 클래스.  
값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스라면 equals를 재정의하지 않아도 된다. ex) Enum

## equals 재정의 일반 규약
컬렉션 클래스들을 포함해 수 많은 클래스는 전달받은 객체가 equals 규약을 지킨다고 가정하고 동작한다.

### 반사성
null이 아닌 모든 참조 값 x에 대해 ```x.equals(x)```는 true  

### 대칭성
null이 아닌 모든 참조 값 x,y에 대해 ```x.equals(y)```가 true면 ```y.equals(x)```도 true  

- 대칭성 위배 메서드
  
```java
@Override public boolean equals(Object o) {
    if (o instanceof CaseInsensitiveString)
        return s.equalsIgnoreCase(
                ((CaseInsensitiveString) o).s);
    if (o instanceof String)  // 한 방향으로만 작동한다!
        return s.equalsIgnoreCase((String) o);
    return false;
}
```  
toString 메서드는 원본 문자열의 대소문자를 그대로 돌려주지만 equals에서는 대소문자를 무시한다.

- 수정 후

  
```java
@Override public boolean equals(Object o) {
    return o instanceof CaseInsensitiveString &&
        ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);
}
```  

CaseInsensitiveString의 equals와 String과의 연동을 포기해야 한다.

### 추이성
null이 아닌 모든 참조 값 x,y,z에 대해 ```x.equals(y)```가 true이고 ```y.equals(z)```도 true면 ```x.equals(z)```도 true  

### 일관성
null이 아닌 모든 참조 값 x,y에 대해 ```x.equals(y)```를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환

### null-아님
null이 아닌 모든 참조 값 x에 대해 ```x.equals(null)```은 false
