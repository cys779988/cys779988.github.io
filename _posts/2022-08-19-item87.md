---
title:  "커스텀 직렬화 형태를 고려해보자"
excerpt: \[Effective Java\] 커스텀 직렬화 형태를 고려해보자
categories:
  - effectiveJava
---

## 기본 직렬화 형태는 잘 고려해서 사용하자
기본 직렬화 형태는 유연성, 성능, 정확성 측면에서 신중히 고민한 후 합당할 때만 사용해야 한다. 일반적으로 우리가 직접 설계하더라도 기본 직렬화 형태와 거의 같은 결과가 나올 경우에만 기본 형태를 써야 한다.  
어떤 객체의 기본 직렬화 형태는 그 객체를 루트로 하는 객체 그래프의 물리적 모습을 나름 효율적으로 인코딩한다. 다시 말해, 객체가 포함한 데이터들과 그 객체에서부터 시작해 접근할 수 있는 모든 객체를 담아내며, 심지어 이 객체들이 연결된 위상까지 기술한다. 그러나 아쉽게도 이상적인 직렬화 형태라면 물리적인 모습과 독립된 논리적인 모습만을 표현해야 한다.  
**객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.**

#### 기본 직렬화 형태에 적합한 클래스 예시
  
```java
public class Name implements Serializable {
    /*
		 * 성. null이 아니어야 함.
		 * @serial
		 */
    private final String lastName;

		/*
		 * 이름. null이 아니어야 함.
		 * @serial
		 */
    private final String firstName;

		/*
		 * 중간이름. 중간이름이 없다면 null.
		 * @serial
		 */
    private final String middleName;

    ...
}
```  

성명은 논리적으로 이름, 성, 중간이름이라는 3개의 문자열로 구성되며, 위 코드의 인스턴스 필드들은 이 논리적 구성요소를 정확히 반영했다.  
기본 직렬화 형태가 적합하다고 결정했더라도 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때가 많다. 위의 Name 클래스의 경우에는 readObject 메서드가 lastName과 firstName 필드가 null이 아님을 보장해야 한다.

#### 기본 직렬화 형태에 적합하지 않은 클래스 예시

  
```java
public final class StringList implements Serializable {
    private transient int size   = 0;
    private transient Entry head = null;

    // 이제는 직렬화되지 않는다.
    private static class Entry {
        String data;
        Entry  next;
        Entry  previous;
    }

    // 지정한 문자열을 이 리스트에 추가한다.
    public final void add(String s) {  }

    /**
     * 이 {@code StringList} 인스턴스를 직렬화한다.
     *
     * @serialData 이 리스트의 크기(포함된 문자열의 개수)를 기록한 후
     * ({@code int}), 이어서 모든 원소를(각각은 {@code String})
     * 순서대로 기록한다.
     */
    private void writeObject(ObjectOutputStream s)
            throws IOException {
        s.defaultWriteObject();
        s.writeInt(size);

        // 모든 원소를 올바른 순서로 기록한다.
        for (Entry e = head; e != null; e = e.next)
            s.writeObject(e.data);
    }

    private void readObject(ObjectInputStream s)
            throws IOException, ClassNotFoundException {
        s.defaultReadObject();
        int numElements = s.readInt();

        // 모든 원소를 읽어 이 리스트에 삽입한다.
        for (int i = 0; i < numElements; i++)
            add((String) s.readObject());
    }

    ...
}
```  