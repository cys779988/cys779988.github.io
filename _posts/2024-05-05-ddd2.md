---
title:  "DDD 애그리거트"
excerpt: DDD(Domain Driven Design) 애그리거트
categories:
  - ddd
---

## 애그리거트
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 **애그리거트**다. 수많은 객체를 애그리거트로 묶어서 바라면 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
- 애그리거트는 복잡한 도메인을 단순한 구조로 만들어준다. 복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하기 쉬워진다.
- 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 가진다.
- 애그리거트는 경계를 갖는다. 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. 독립된 객체 군이며 다른 애그리거트를 관리하지 않는다.
- 도메인에 대한 이해도가 증가할수록 애그리거트의 실제 크기는 줄어든다. 한 개의 엔티티 객체만 갖는 애그리거트가 많으며, 두 개 이상의 엔티티로 구성되는 애그리거트는 드물다.

## 애그리거트 루트
- 애그리거트 전체를 관리할 주체. 애그리거트의 대표 엔티티.
- 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것.
- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.

## 트랜잭션 범위
- 트랜잭션에서 잠금 대상이 많아진다는 것은 그만큼 동시에 처리할 수 있는 트랜잭션 개수가 줄어든다는 것을 의미한다. 이는 전체적인 처리량을 떨어뜨린다.
- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다. 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 더 높아진다.
- 애그리거트는 최대한 독립적이어야 한다. 다른 애그리거트의 기능에 의존하기 시작하면 결합도가 높아지고 향후 수정 비용이 증가하게 되므로 다른 애그리거트의 상태를 변경하지 말아야 한다.
- 부득이하게 한 트랜잭션에서 두 개 이상의 애그리거트를 수정해야 한다면 응용 서비스에서 두 애그리거트를 수정해야 한다.

## 리포지터리
- 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.
- 애그리거트를 구하는 Repository 메서드는 완전한 애그리거트를 제공해야 한다. 예를 들어 주문 애그리거트는 주문자, 주문상품 등 모든 구성요소를 포함하고 있어야 한다.

  
```java
Order order = orderRepository.findById(orderId);

// order가 온전한 애그리거트가 아니면 NullPointException과 같은 문제가 발생한다.
order.cancel();
```  

###### Reference
- 도메인 주도 개발 시작하기, 최범균 지음