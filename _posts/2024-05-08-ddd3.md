---
title:  "DDD 리포지터리와 모델"
excerpt: DDD(Domain Driven Design) 리포지터리와 모델
categories:
  - ddd
---

## 리포지터리

#### 모듈 위치
리포지터리 인터페이스는 도메인 영역에 속하고, 리포지터리를 구현한 클래스는 가능하면 인프라스트럭처 영역에 위치 시켜서 인프라스트럭처에 대한 의존을 낮춰야 한다.

> 스프링 데이터 JPA를 사용할 때 리포지터리 인터페이스만 정의하면 나머지 리포지터리 구현 객체는 스프링 데이터 JPA가 알아서 만들어준다. 그래서 리포지터리 인터페이스를 구현한 클래스를 직접 작성할 일은 거의 없다. 

## 매핑 구현
- 애그리거트 루트는 엔티티이므로 @Entity로 매핑 설정한다.
- 밸류는 @Embeddable로 매핑 설정한다.
- 밸류 타입 프로퍼티는 @Embedded로 매핑 설정한다.

  
```java
@Entity
public class Order {
    ...
    
    @Embedded
    private Orderer orderer;

    @Embedded
    private ShippingInfo shippingInfo;
}

@Embeddable
public class Orderer {

    // MemberId에 정의된 컬럼 이름을 변경하기 위해 @AttributeOverride 애너테이션 사용
    // Orderer의 memberId는 Member 애그리거트를 ID로 참조한다.
    @Embedded
    @AttributeOverrides(
            @AttributeOverride(name = "id", column = @Column(name = "orderer_id"))
    )
    private MemberId memberId;

    @Column(name = "orderer_name")
    private String name;
}

@Embeddable
public class MemberId implements Serializable {
    
    // Member의 ID 타입으로 사용되는 MemberId는 id 프로퍼티와 매핑되는 테이블 컬럼 이름으로 "member_id"를 지정한다.
    @Column(name = "member_id")
    private String id;
}

@Embeddable
public class ShippingInfo {
    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "zipCode", column = @Column(name = "shipping_zipcode")),
            @AttributeOverride(name = "address1", column = @Column(name = "shipping_addr1")),
            @AttributeOverride(name = "address2", column = @Column(name = "shipping_addr2"))
    })
    private Address address;
    
    @Column(name = "shipping_message")
    private String message;
    
    @Embedded
    private Receiver receiver;
}


```  

#### 필드 접근 방식
- 엔티티에 프로퍼티를 위한 get/set 메서드를 추가하면 도메인의 의도가 사라지고 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높아진다. 특히 set 메서드는 내부 데이터를 변경하는 수단이 되기 때문에 캡슐화를 깨는 원인이 된다.
- set 메서드 대신 의도가 잘 드러나는 기능을 제공해야 한다. 예를들어 setState() 보다 cancel() 메서드가 도메인을 더 잘 표현한다.
- 객체가 제공할 기능 중심으로 엔티티를 구현하게끔 유도하려면 JPA 매핑 처리를 프로퍼티 방식이 아닌 필드 방식으로 선택해서 불필요한 get/set 메서드를 구현하지 말아야 한다.

  
```java
@Entity
@Access(AccessType.FIELD)
public class Order {
    @EmbeddedId
    private OrderNo number;
    
    @Column(name = "state")
    @Enumerated(EnumType.STRING)
    private OrderState state;
    
    ... // 도메인 기능 구현
    ... // 필요한 get 메서드 제공
}
```  

#### AttributeConverter를 이용한 밸류 매핑 처리

```java
// 두 개 프로퍼티를 한 개 컬럼에 매핑해야 할 때 ex) 1000mm
public class Length {
    private int value;
    private String unit;
}
```

두 개 이상의 프로퍼티를 가진 밸류 타입을 한 개 컬럼에 매핑하려면 AttributeConverter를 이용해야 한다.

  
```java
// AttributeConverter 인터페이스를 구현한 클래스는 @Converter를 적용한다.
@Converter(autoApply = true)
public class MoneyConverter implements AttributeConverter<Money, Integer> {
    
    @Override
    public Integer convertToDatabaseColumn(Money money) {
        return money == null  ? null : money.getValue();
    }

    @Override
    public Money convertToEntityAttribute(Integer value) {
        return value == null  ? null : new Money(value);
    }
}
```  

- autoApply 속성을 true로 지정하면 모델에 출현하는 모든 Money 타입의 프로퍼티에 대해 MoneyConverter를 자동으로 적용한다.
- autoApply 속성을 false로 지정하면 프로퍼티 값을 변환할 때 `@Convert(converter = MoneyConverter.class)` 와 같이 사용할 컨버터를 직접 지정해야 한다.

#### 밸류 컬렉션 별도 테이블 매핑
  
```java
@Entity
public class Order {
    @EmbeddedId
    private OrderNo number;
    ...
    
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "order_line", joinColumns = @JoinColumn(name = "order_number"))
    @OrderColumn(name = "line_idx")
    private List<OrderLine> orderLines;
}

@Embeddable
public class OrderLine {
    @Embedded
    private ProductId productId;
    
    @Column(name = "price")
    private Money price;
    
    @Column(name = "quantity")
    private int quantity;

    @Column(name = "amounts")
    private Money amounts;
    
    ...
}
```  

- @OrderColumn 애너테이션은 지정한 컬럼에 리스트의 인덱스 값을 저장한다.
- @CollectionTable은 밸류를 저장할 테이블을 지정한다. name 속성은 테이블 이름을 지정하고 joinColumns 속성은 외부키로 사용할 컬럼을 지정한다.

#### 밸류 컬렉션 한 개 컬럼 매핑
- 밸류 컬렉션을 별로 테이블이 아닌 한 개 컬럼에 저장해야 할 때가 있다. 예를 들어 이메일 주소 목록을 Set으로 보관하고 DB에는 한 개 컬럼에 콤마로 구분해서 저장해야 할 때가 있다.
- AttributeConverter를 사용하면 밸류 컬렉션을 한 개 컬럼에 쉽게 매핑할 수 있다.

  
```java
public class EmailSet {
    private Set<Email> emails = new HashSet<>();

    public EmailSet(Set<Email> emails) {
        this.emails.addAll(emails);
    }

    public Set<Email> getEmails() {
        return Collections.unmodifiableSet(emails);
    }
}
```  

  
```java
@Converter(autoApply = true)
public class EmailSetConverter implements AttributeConverter<EmailSet, String> {
    @Override
    public String convertToDatabaseColumn(EmailSet emailSet) {
        if (emailSet == null) return null;
        return emailSet.getEmails().stream()
                .map(email -> email.getAddress())
                .collect(Collectors.joining(","));
    }

    @Override
    public EmailSet convertToEntityAttribute(String dbData) {
        if (dbData == null) return null;
        String[] emails  = dbData.split(",");
        Set<Email> emailSet = Arrays.stream(emails)
                .map(value -> new Email(value))
                .collect(Collectors.toSet());
        return new EmailSet(emailSet);
    }
}
```  


###### Reference
- 도메인 주도 개발 시작하기, 최범균 지음