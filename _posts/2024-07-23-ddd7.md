---
title:  "DDD 이벤트"
excerpt: DDD(Domain Driven Design) 이벤트
categories:
  - ddd
---

## 이벤트 개요
비동기 이벤트를 사용하면 두 시스템 간의 결합을 크게 낮출 수 있다.

#### 이벤트 구성요소
도메인 모델에 이벤트를 도입하려면 네 개의 구성요소를 구현해야 한다. 
- 이벤트 : 과거에 벌어진 어떤 것. 예를 들어 주문을 취소했다면 '주문을 취소했음 이벤트'가 벌어졌다고 할 수 있다.
- 이벤트 생성 주체 : 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체이다. 이들 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생시킨다.
- 이벤트 핸들러(구독자) : 이벤트 생성 주체가 발생한 이벤트에 반응한다. 생성 주체가 발생한 이벤트를 전달받아 이벤트에 담긴 데이터를 이용해서 원하는 기능을 실행한다.
- 이벤트 디스패처(퍼블리셔) : 이벤트 생성 주체는 이벤트를 생성해서 디스패처에 이벤트를 전달한다. 이벤트를 전달받은 디스패처는 해당 이벤트를 처리할 수 있는 핸들러에 이벤트를 전파한다. 이벤트 디스패처의 구현 방식에 따라 이벤트 생성과 처리를 동기나 비동기로 실행하게 된다.

#### 이벤트의 구성
이벤트는 발생한 이벤트에 대한 정보를 담는다.
- 이벤트 종류 : 클래스 이름으로 이벤트 종류를 표현
- 이벤트 발생 시간
- 추가 데이터 : 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보

  
```java
// 현재 기준으로 과거에 벌어진 것을 표현하기 때문에 클래스 이름은 과거시제를 사용
public class ShippingInfoChangedEvent {
    private String orderNumber;
    private long timestamp;
    private ShippingInfo newShippingInfo;
    
    ...
}

// 이벤트를 발생시키는 주체 Order 애그리거트
public class Order {
    public void changeShippingInfo(ShippingInfo newShippingInfo) {
        verifyNotYetShipped();
        setShippingInfo(newShippingInfo);
        Events.raise(new ShippingInfoChangedEvent(number, newShippingInfo));
    }
    
    ...
}

// 디스패처로부터 이벤트를 전달받아 필요한 작업을 수행
public class ShippingInfoChangedHandler {
    @EventListener(ShippingInfoChangedEvent.class)
    public void handle(ShippingInfoChangedEvent event) {
        // 이벤트가 필요한 데이터를 담고 있지 않다면
        // 레포지토리, 조회 API, 직접 DB 접근 등 필요한 데이터를 조회해야 한다.
        Order order = orderRepository.findById(event.getOrderNo());
        shippingInfoSynchronizer.sync(
                event.getOrderNumber(),
                event.getNewShippingInfo()
        );
    }
}
```  

#### 이벤트 용도
1. 트리거 : 도메인의 상태가 바뀔 때 다른 후처리를 실행. 주문을 취소하면 환불을 처리해야 하는데 이때 환불 처리를 위한 트리거로 주문 취소 이벤트 사용.
2. 서로 다른 시스템 간의 데이터 동기화 : 배송지를 변경하면 외부 배송 서비스에 바뀐 배송지 정보를 전송해야 한다. 주문 도메인은 배송지 변경 이벤트를 발생시키고 이벤트 핸들러는 외부 배송 서비스와 배송지 정보를 동기화. 

#### 이벤트 장점
- 서로 다른 도메인 로직이 섞이는 것을 방지할 수 있다.
- 기능 확장에 용이하다.