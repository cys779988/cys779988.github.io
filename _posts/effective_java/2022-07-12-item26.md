---
title:  "로 타입은 사용하지 말자"
excerpt: \[Effective Java\] 로 타입은 사용하지 말자
categories:
  - effectiveJava
---


## 제네릭 타입
클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 제네릭 클래스 혹은 제네릭 인터페이스라 하고 통틀어 제네릭 타입이라 한다.  
각각의 제네릭 타입은 일련의 매개변수화 타입을 정의한다. 먼저 클래스 이름이 나오고, 이어서 꺾쇠괄호 안에 실제 타입 매개변수들을 나열한다. ```List<String>```은 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다. 여기서 String이 ```List<E>```의 정규 타입 매개변수 E에 해당하는 실제 타입 매개변수다.

## 로타입
제네릭 타입을 하나 정의하면 그에 딸린 로 타입도 함께 정의된다. 로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. 예컨대 ```List<E>```의 로 타입은 List다. 로 타입은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도래하기 전 코드와 호환되도록 하기 위함이다.

  
```java
private final Collection stamps = ...;
```  

위 코드를 사용하면 실수로 다른 타입을 넣어도 아무 오류 없이 컴파일되고 실행된다. 그 후 런타임에 오류가 발생하게 된다.

  
```java
for (Iterator i = stamps.iterator(); i.hasNext();) {
    Stamp stamp = (Stamp) i.next();
    stamp.cancel();
}
```  

오류는 가능한 한 발생 즉시, 이상적으로는 컴파일할 때 발견하는 것이 좋다. 위 예에서는 오류가 발생하고 한참 뒤인 런타임에야 알아챌 수 있는데, 이렇게 되면 런타임에 문제를 겪는 코드와 원인을 제공한 코드가 물리적으로 상당히 떨어져 있을 가능성이 커진다.  

## 매개변수화된 컬렉션 타입

  
```java
private final Collection<Stamp> stamps = ...;
```  

이렇게 선언하면 컴파일러는 stamps에는 Stamp의 인스턴스만 넣어야 함을 인지하게 된다. 따라서 아무런 경고 없이 컴파일된다면 의도대로 동작할 것임을 보장한다.  
컴파일러는 컬렉션에서 원소를 꺼내는 모든 곳에 보이지 않는 형변환을 추가하여 절대 실패하지 않음을 보장한다.

## 로타입과 매개변수화 타입
로타입은 호환성 때문에 어쩔 수 없이 언어 차원에서 막아 놓지 않았지만 **로타입은 절대로 써서는 안 된다.** 로타입을 쓰면 제네릭이 안겨주는 안정성과 표현력을 모두 잃게 된다. ```List``` 같은 로타입은 사용해서는 안 되나, ```List<Object>```처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다.  
로타입인 ```List```와 매개변수화 타입인 ```List<Object>```의 차이는 로타입은 제네릭 타입에서 완전히 발을 뺀 것이고, 매개변수화 타입은 모든 타입을 허용한다는 의사를 컴파일러에 명확히 전달한 것이다. 매개변수로  ```List``` 받는 메서드에는 ```List<String>```을 넘길 수 있지만, ```List<Object>```를 받는 메서드에는 넘길 수 없다. 이는 제네릭의 하위 타입 규칙 때문이다. ```List<Object>``` 같은 매개변수화 타입을 사용할 때와 달리 ```List```같은 로타입을 사용하면 타입 안정성을 잃게 된다.


## 비한정적 와일드카드 타입
제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 물음표를 사용하자. 예컨대 제네릭 타입인 ```Set<E>```의 비한정적 와일드카드 타입은 ```Set<?>```다. 이것이 어떤 타입이라도 담을 수 있는 가장 범용적인 매개변수화 Set 타입이다.

  
```java
// 로타입
static int numElementsInCommon(Set s1, Set s2) { ... }

// 비한적 와일드카드 타입
static int numElementsInCommon(Set<?> s1, Set<?> s2) { ... }
```  

비한정적 와일드카드 타입은 안전하고 로타입은 안전하지 않다. 로타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다. 반면 ```Collection<?>```에는 null 외에는 어떤 원소도 넣을 수 없고 컬렉션에서 꺼낼 수 있는 객체의 타입도 전혀 알 수 없게 했다. 이러한 제약을 받아들일 수 없다면 제네릭 메서드나 한정적 와일드카드 타입을 사용하면 된다.

## 로타입이 사용되는 경우
### class 리터럴
자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했다. 예를 들어 ```List.class, String[].class, int.class```는 허용하고 ```List<String>.class, List<?>.class```는 허용하지 않는다.

### instanceof 연산자
런타임에는 제네릭 타입 정보가 지워지므로 instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다. 그리고 로타입이든 비한정적 와일드카드 타입이든 instanceof는 완전히 똑같이 동작한다. 비한정적 와일드카드 타입의 꺾쇠괄호와 물음표는 아무런 역할 없이 코드만 지저분하게 만드므로, 차라리 로타입을 쓰는편이 깔끔하다.

  
```java
if(o instanceof Set) {
    Set<?> s = (Set<?>) o;
    ...
}
```  
o의 타입이 Set임을 확인한 다음 와일드카드 타입으로 형변환해야 한다. 이는 검사 형변환이므로 컴파일러 경고가 뜨지 않는다.

## 용어 정리

용어 | 예
---- | ----
매개변수화 타입 | ```List<String>```
실제 타입 매개변수 | ```String```
제네릭 타입 | ```List<E>```
정규 타입 매개변수 | ```E```
비한정적 와일드카드 타입 | ```List<?>```
로타입 | ```List```
한정적 타입 매개변수 | ```<E extends Number>```
재귀적 타입 한정 | ```<T extends Comparable<T>>```
한정적 와일드카드 타입 | ```List<? extends Number>```
제네릭 메서드 | ```static <E> List<E> asList(E[] a)```
타입 토큰 | ```String.class```