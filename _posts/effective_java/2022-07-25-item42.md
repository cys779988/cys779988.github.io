---
title:  "익명 클래스보다는 람다를 사용하라"
excerpt: \[Effective Java\] 익명 클래스보다는 람다를 사용하라
categories:
  - effectiveJava
---

## 익명 클래스
예전에는 자바에서 함수 타입을 표현할 때 추상 메서드를 하나만 담은 인터페이스(혹은 추상클래스)를 사용하여 특정 함수나 동작을 나타내는 데 썼다.

#### 익명 클래스의 인스턴스를 함수 객체로 사용
  
```java
Collections.sort(words, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(), s2.length());
    }
})
```  

전략패턴처럼, 함수 객체를 사용하는 과거 객체 지향 디자인 패턴에서는 익명 클래스면 충분했다. 위 코드는 Comparator 인터페이스가 정렬을 담당하는 추상 전략을 뜻하며, 문자열을 정렬하는 구체적인 전략을 익명 클래스로 구현했다. 하지만 익명 클래스 방식은 코드가 너무 길기 때문에 함수형 프로그래밍에 적합하지 않다.

## 람다식
자바 8에서 추상 메서드 하나짜리 인터페이스는 특별한 대우를 받게 되었다. 함수형 인터페이스라 부르는 인터페이스들의 인스턴스를 람다식을 사용해 만들 수 있게 된 것이다. 함수나 익명 클래스와 개념은 비슷하지만 코드는 훨씬 간결하다.

  
```java
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```  

#### 람다와 컴파일러 타입 추론
타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자. 컴파일러가 오류를 낼 때만 해당 타입을 명시하면 된다.  

컴파일러가 타입을 추론하는 데 필요한 타입 정보 대부분은 제네릭에서 얻는다. 그래서 람다를 사용할 때 제네릭의 사용은 더 중요해진다. 우리가 이 정보를 제공하지 않으면 컴파일러는 람다의 타입을 추론할 수 없게 되어, 우리가 일일이 명시해야 한다.

#### 람다 사용시 주의사항
람다는 이름이 없고 문서화도 못 한다. 따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다. 람다는 한 줄 일때 가장 좋고 길어야 세 줄 안에 끝내는게 좋다.

## 람다 대신 익명 클래스를 사용해야 할 때

#### 추상 클래스의 인스턴스를 만들 때
람다는 함수형 인터페이스에서만 쓰인다. 예컨대 추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없으니, 익명 클래스를 써야 한다.

#### 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때

#### 함수 객체가 자신을 참조
람다는 자신을 참조할 수 없다. 람다에서의 this 키워드는 바깥 인스턴스를 가리킨다. 반면 익명 클래스에서의 this는 익명 클래스의 인스턴스 자신을 가리킨다. 그래서 함수 객체가 자신을 참조해야 한다면 반드시 익명 클래스를 써야 한다.  


> 람다도 익명 클래스처럼 직렬화 형태가 구현별로 다를 수 있다. 따라서 람다를 직렬화하는 일은 극히 삼가야 한다.(익명 클래스의 인스턴스도 마찬가지) 직렬화해야만 하는 함수 객체가 있다면 private 정적 중첩 클래스의 인스턴스를 사용하자.